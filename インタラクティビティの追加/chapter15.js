//なぜReactのstateの配列は「直接書き換えてはダメ」なのか？
//一番大事なポイントはこれです。Reactは 「stateが以前と違うものに変わった」ことを検知して、初めて画面を再描画します。
//ここに、ジュースがたくさん入った箱（配列）があると想像してください。
//ダメな例: 箱の中から1本のジュースをこっそり別のものに入れ替える。（array[0] = '新しいジュース' や array.push('新しいジュース')）
//これだと、箱自体は同じものですよね。Reactは「箱が変わってないな」と判断し、中身が変わったことに気づけません。そのため、画面が更新されない、という問題が起こります。
//良い例: 新しい箱を用意して、今までのジュースを全部入れ、さらに新しいジュースを追加する。（const newArray = [...array, '新しいジュース']）
//そして「これからはこの新しい箱を使ってください」とReactに渡します。Reactは「お、前と違う箱が来たな！」とすぐに気づき、画面を正しく再描画してくれます。

//この 「常に新しい配列（箱）を作って渡す」 というのが、Reactにおける配列更新の鉄則です。これを「イミュータビリティ（不変性）を保つ」と言います。
//配列を更新する3つの基本パターン
//元の配列を直接書き換える代わりに、新しい配列を作るための便利なメソッドがJavaScriptには用意されています。主にこの3つを覚えればOKです。
//1. 要素を追加する：スプレッド構文 ...
//元の配列の全要素を展開し、新しい要素を追加した「新しい配列」を簡単に作れます。

// artists配列の末尾に、新しいartistを追加したい
setArtists([
  ...artists, // ← 古い配列の要素をここに全部コピー
  { id: nextId, name: "新しい名前" }, // ← 新しい要素を追加
]);
//push() の代わりに、このスプレッド構文を使いましょう。
//2. 要素を削除する：.filter()
//「条件に合うものだけを残した、新しい配列を作る」メソッドです。削除したい要素を「除外する」条件を指定します。

// artist.id と同じIDを持つ要素を削除したい
setArtists(
  artists.filter((a) => a.id !== artist.id)
  //           ↑「a.idが、削除したいartist.idと『違う』ものだけ集めてね」
);
//filter は元の配列を一切変更せず、条件に合うものだけを集めた新しい配列を返してくれるので、Reactにピッタリです。

//3. 要素を変更（更新）する：.map()
////配列の全要素を1つずつチェックし、それぞれを新しい要素に変換した「新しい配列」を作ります。

// idが一致するカウンターの数字を+1したい
setCounters(
  counters.map((counter, index) => {
    if (index === 更新したいindex) {
      // 更新したい要素の場合、新しい値を返す
      return counter + 1;
    } else {
      // それ以外の要素は、そのままの値を返す
      return counter;
    }
  })
);
//map も元の配列は変更せず、必ず新しい配列を返します。

//【最重要】配列の中のオブジェクトを更新するときの注意点
//これが一番ハマりやすい落とし穴です。配列の中身がオブジェクトの場合、更新は少しだけ複雑になります。
//解決策: .map() を使って、更新したいオブジェクト自体も新しいものに作り変える必要があります。
// myListの中から、特定のartworkのseenプロパティを更新したい
setMyList(
  myList.map((artwork) => {
    if (artwork.id === artworkId) {
      // 【ここが重要！】更新対象のオブジェクトもコピーして、変更を加える
      return { ...artwork, seen: true };
      //       ↑ オブジェクトのスプレッド構文でコピー＆更新
    } else {
      // 変更しないオブジェクトは、そのまま返す
      return artwork;
    }
  })
);
//「外側の配列」と「内側の更新したいオブジェクト」の両方を新しくするのがポイントです。

//もっと楽したいなら： Immer を使おう
//ここまでのルールは、ネストが深くなるとコードが少し長くなりがちです。
//Immer というライブラリを使うと、まるで普通のJavaScriptのように、直感的にコードが書けます。
// Immerを使った更新
updateMyList((draft) => {
  // draft（下書き）に対しては、直接書き換えるようなコードが書ける！
  const artwork = draft.find((a) => a.id === artworkId);
  artwork.seen = true;
});
//draft という特別なオブジェクトを書き換えると、Immerが裏側で自動的に、ここまで説明した面倒なコピー作業をすべて肩代わりして、新しいstateを安全に作ってくれます。コードがスッキリしておすすめです。
