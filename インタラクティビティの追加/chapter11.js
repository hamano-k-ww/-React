//レンダーとコミット
//コンポーネントが料理人として厨房に立ち、食材を調理して美味しい料理を作っている様子をイメージしてみてください
    //1.レンダーのトリガ（お客様の注文を厨房に伝える）
    //2.コンポーネントのレンダー（厨房で注文の品を料理する）
    //3.DOM へのコミット（テーブルに注文の品を提供する）

//ステップ 1：レンダーのトリガ 
//コンポーネントがレンダーされる理由には 2 つあります。
    //1.コンポーネントの初回レンダー。
    //2.コンポーネント（またはその祖先のいずれか）の state の更新。
//アプリが開始するときには、初回のレンダーをトリガする必要があります。自力で行う場合には、ターゲットとなる DOM ノードに対して createRoot を呼び出し、作成されたルートの render メソッドを、コンポーネントに対して呼び出します。

import Image from './Image.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'))
root.render(<Image />);
document.getElementById('root'):
// 1.HTMLファイルにあらかじめ用意されているであろう <div id="root"></div> という場所を探します。これは、Reactアプリ全体を「ここに表示してください」という目印です。
    //レストランで言うと、「お店の入り口はここですよ」と場所を確認しているようなものです。
//2.createRoot(...): 見つけた場所に、Reactアプリを管理するための「店長」のようなものを配置します。
//3.root.render(<Image />): そして店長に「では、最初に <Image /> コンポーネントを注文してください！」と命令します。これが、Reactにとって最初の仕事の**きっかけ（トリガ）**となります。

//state 更新後の再レンダー 
//コンポーネントが最初にレンダーされた後、set 関数を使って state を更新することで、さらなるレンダーをトリガすることができます。
// コンポーネントの state を更新すると、自動的にレンダーがキューイングされます。
//分かりやすく言うと、一度表示された後、useState などで管理しているデータ（State）が更新されると、それが2回目以降の「トリガ」になります。例えば、ボタンクリックで setCount(count + 1) が呼ばれるような場面です。
    //レストランで言うと、お客さんが「すみません、お水ください！」と追加注文するようなものです。これもウェイター（React）が動くきっかけになります。


//ステップ 2：React がコンポーネントをレンダー 
//きっかけ（注文）を受け取ると、Reactは**「じゃあ、最終的に画面はどんな見た目になるべきか？」を計算します。この計算プロセスが「レンダー」**です。
//【超重要ポイント】 この段階では、まだ実際の画面は一切変わりません。
//コード例 
//もし、最初の注文が <Gallery /> だった場合を見てみましょう。

// index.js
import Gallery from './Gallery.js';
// ...（略）...
root.render(<Gallery />); // 注文はGalleryコンポーネント！

// Gallery.js （料理長コンポーネント）
export default function Gallery() {
  return (
    <section>
      <h1>感動的な彫刻</h1>
      <Image />
      <Image />
      <Image />
    </section>
  );
}

// Image.js （見習いコンポーネント）
export default function Image() {
  return (
    <img src="https://i.imgur.com/ZF6s192.jpg" alt="彫刻" />
  );
}

//1． root.render(<Gallery />) がトリガされると、Reactはまず Gallery コンポーネント（料理長）を呼び出します。
//2．Gallery は「<section> と <h1>、それから3つの <Image /> コンポーネントが欲しい」という指示書（JSX）を返します。
//3． Reactは「なるほど、でもまだ <Image /> の中身がわからないな」と考え、次に見習いの <Image /> コンポーネントを3回呼び出します。
//4． 3つの <Image /> はそれぞれ「私は具体的な <img> タグです」と返します。
//5． これでようやく、Reactは全ての部品が揃った最終的な**完成図（設計図）**を頭の中に描くことができます。
// この一連の計算プロセスが「レンダー」です。まだ料理はテーブルに運ばれていません。


// ステップ３：コミット（実際の工事）
// 設計図が出来上がったら、いよいよReactが実際の画面（DOM）を書き換えます。これを**「コミット」**と呼びます。Reactはとても賢いので、違いがある部分だけを最小限で工事します。
// このコンポーネントは、親から毎秒新しい time を受け取って再レンダーされるとします。

export default function Clock({ time }) {
  return (
    <>
      <h1>{time}</h1>
      <input />
    </>
  );
}
// コードの解説
// 初回レンダー時
// レンダー（設計図）: Reactは <h1> と <input> を含む設計図を作ります。
// コミット（工事）: 画面は空っぽなので、設計図通りに <h1> と <input> の両方を画面に作り出します。

// 再レンダー時（1秒後）
// トリガ: 親コンポーネントが新しい time で Clock を再レンダーします。
// レンダー（設計図）: Reactは再び Clock を呼び出し、新しい time が入った設計図を作ります。（例：<h1>21:30:01</h1> と <input />）
// コミット（工事）: ここでReactの賢さが光ります。
// 比較:「前の設計図」と「新しい設計図」を比べます。
// <h1>: 中身が 21:30:00 から 21:30:01 に変わっている！ → OK、ここだけ書き換えよう。
// <input>: 前と同じ場所に同じ <input> がある。設計図上、何も変わっていない。もしユーザーが何か文字を打ち込んでいても、Reactは「ここは変更なし」と判断します。 → OK、ここは触らないでおこう。
// このおかげで、時計の表示は更新されつつも、あなたがいい感じに入力していた文字は消えずに残るのです。
